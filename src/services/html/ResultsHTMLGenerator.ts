/**
 * HTML Results Generator
 * Generates WordPress-compatible HTML for race results pages
 */

import type { Runner } from '../../types';
import { parseChampionshipRaceHistory } from '../../raceLogic';

export interface MonthlyResults {
  month: number;
  year: number;
  runners_5k: Runner[];
  runners_10k: Runner[];
}

export class ResultsHTMLGenerator {
  /**
   * Generate complete year results HTML page
   */
  generateYearResultsHTML(year: number, monthlyResults: MonthlyResults[]): string {
    // Sort months chronologically
    const sortedResults = [...monthlyResults].sort((a, b) => a.month - b.month);

    const monthSections = sortedResults
      .map((monthData) => this.generateMonthSection(monthData))
      .join('\n\n');

    return `
      <div style="max-width: 1200px; margin: 0 auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px;">
        <h1 style="font-size: 36px; font-weight: bold; margin-bottom: 32px; color: #1f2937;">${year} Results</h1>
        ${monthSections}
        <div style="margin-top: 40px; padding: 16px; background: #f3f4f6; border-radius: 8px; text-align: center;">
          <p style="margin: 0; color: #6b7280; font-size: 14px;">
            Results generated by Bushrun Race Day App
          </p>
        </div>
      </div>
    `;
  }

  /**
   * Generate a single month section with 5k and 10k results
   */
  private generateMonthSection(monthData: MonthlyResults): string {
    const monthName = this.getMonthName(monthData.month);

    const section5k =
      monthData.runners_5k.length > 0
        ? `
          <h3 style="font-size: 20px; font-weight: 600; margin: 24px 0 16px 0; color: #374151;">5k Result</h3>
          ${this.generateDistanceTable(monthData.runners_5k, '5km', monthData.month)}
        `
        : '';

    const section10k =
      monthData.runners_10k.length > 0
        ? `
          <h3 style="font-size: 20px; font-weight: 600; margin: 24px 0 16px 0; color: #374151;">10k Result</h3>
          ${this.generateDistanceTable(monthData.runners_10k, '10km', monthData.month)}
        `
        : '';

    return `
      <div style="margin-bottom: 48px;">
        <h2 style="font-size: 28px; font-weight: bold; margin-bottom: 16px; color: #1f2937; border-bottom: 3px solid #667eea; padding-bottom: 8px;">
          ${monthName}
        </h2>
        ${section5k}
        ${section10k}
      </div>
    `;
  }

  /**
   * Generate results table for a specific distance and month
   */
  private generateDistanceTable(runners: Runner[], distance: '5km' | '10km', month: number): string {
    // Extract race results from championship_races for this specific month
    interface RunnerWithRaceData {
      runner: Runner;
      race_position: string;
      race_time: number; // in seconds
      race_points: number;
      annual_points: number; // cumulative points for the year up to this month
    }

    const runnersWithRaceData = runners
      .map((runner) => {
        const championshipField = distance === '5km' ? 'championship_races_5k' : 'championship_races_10k';
        const history = runner[championshipField];

        if (!history) {
          return null;
        }

        try {
          // Parse the championship history
          const entries = parseChampionshipRaceHistory(history);

          // Find the entry for this month
          const raceEntry = entries.find((e) => e.month === month);

          if (!raceEntry) {
            return null;
          }

          // Calculate cumulative points up to and including this month
          const annualPoints = entries
            .filter((e) => e.month <= month)
            .reduce((sum, e) => sum + e.points, 0);

          // Create extended runner with race data
          return {
            runner,
            race_position: raceEntry.position,
            race_time: raceEntry.time,
            race_points: raceEntry.points,
            annual_points: annualPoints,
          };
        } catch (err) {
          console.error(`Error parsing championship history for ${runner.full_name}:`, err);
          return null;
        }
      })
      .filter((r): r is RunnerWithRaceData => r !== null);

    if (runnersWithRaceData.length === 0) {
      return '<p style="color: #6b7280; font-style: italic;">No results available</p>';
    }

    // Sort by position (numeric positions first, then special positions, then position "0" at bottom)
    const sortedRunners = [...runnersWithRaceData].sort((a, b) => {
      const posA = parseInt(a.race_position, 10);
      const posB = parseInt(b.race_position, 10);

      // Position "0" goes to bottom (unofficial/dnf/timekeeper)
      if (posA === 0 && posB !== 0) return 1;
      if (posB === 0 && posA !== 0) return -1;
      if (posA === 0 && posB === 0) return 0;

      // If both are numeric (and not 0), sort numerically
      if (!isNaN(posA) && !isNaN(posB)) {
        return posA - posB;
      }

      // Numeric positions come first
      if (!isNaN(posA)) return -1;
      if (!isNaN(posB)) return 1;

      // Both are special positions (like "DNF", "ST"), sort alphabetically
      return a.race_position.localeCompare(b.race_position);
    });

    const rows = sortedRunners.map((runner) => this.generateTableRowFromChampionshipData(runner)).join('');

    return `
      <div style="overflow-x: auto; margin-bottom: 24px;">
        <table style="width: 100%; border-collapse: collapse; background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden;">
          <thead>
            <tr style="background-color: #f9fafb;">
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Position</th>
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Name</th>
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Member #</th>
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Time</th>
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Points</th>
              <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb;">Annual Points</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>
    `;
  }

  /**
   * Generate a table row from championship race data
   */
  private generateTableRowFromChampionshipData(data: { runner: Runner; race_position: string; race_time: number; race_points: number; annual_points: number }): string {
    const position = data.race_position;
    const name = this.escapeHtml(data.runner.full_name);
    const memberNumber = data.runner.member_number;
    const time = this.formatTimeFromSeconds(data.race_time);
    const points = data.race_points;
    const annualPoints = data.annual_points;

    // Add medal emoji for top 3
    let medal = '';
    if (position === '1') medal = 'ðŸ¥‡ ';
    else if (position === '2') medal = 'ðŸ¥ˆ ';
    else if (position === '3') medal = 'ðŸ¥‰ ';

    return `
      <tr style="border-bottom: 1px solid #e5e7eb;">
        <td style="padding: 12px; color: #1f2937;">${medal}${position}</td>
        <td style="padding: 12px; color: #1f2937; font-weight: 600;">${name}</td>
        <td style="padding: 12px; color: #6b7280;">${memberNumber}</td>
        <td style="padding: 12px; color: #1f2937;">${time}</td>
        <td style="padding: 12px; color: #1f2937; font-weight: 600;">${points}</td>
        <td style="padding: 12px; color: #1f2937; font-weight: 600;">${annualPoints}</td>
      </tr>
    `;
  }

  /**
   * Format time from seconds to MM:SS
   */
  private formatTimeFromSeconds(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }

  /**
   * Get month name from race number (1-12)
   * Race numbering: 1=Feb, 2=Mar, ..., 11=Dec, 12=Jan (next year)
   */
  private getMonthName(raceNumber: number): string {
    // Map race numbers to month names
    // Race 1 = February (first race of year)
    // Race 12 = January (last race, next calendar year)
    const monthNames = [
      'February',   // Race 1
      'March',      // Race 2
      'April',      // Race 3
      'May',        // Race 4
      'June',       // Race 5
      'July',       // Race 6
      'August',     // Race 7
      'September',  // Race 8
      'October',    // Race 9
      'November',   // Race 10
      'December',   // Race 11
      'January',    // Race 12
    ];
    return monthNames[raceNumber - 1] || 'Unknown';
  }

  /**
   * Escape HTML to prevent XSS
   */
  private escapeHtml(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;',
    };
    return text.replace(/[&<>"']/g, (char) => map[char] || char);
  }
}
